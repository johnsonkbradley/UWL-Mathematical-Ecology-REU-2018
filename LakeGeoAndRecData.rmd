---
title: "R Notebook"
output: html_notebook
---

Libraries
===

```{r}
library(dplyr)
library(ggplot2)
library(ggmap)
library(car)
library(GGally)
library(lubridate)
library(cluster)
library(factoextra)
library(rgdal)
library(sf)
```


Load in the data sets
===

```{r}
tp <- read.csv("tp_regions_10yr.csv", header = T)
secchi <- read.csv("secchi_regions_10yr.csv", header = T)
geo <- read.csv("geo_hu12 data.csv", header = T)
lakesRec <- read.csv("LakesRec.csv", header = T)
```

Need to clean up the data before merging
===

```{r}
lakesRec$Lake.Name <- toupper(lakesRec$Lake.Name) ##make the lake name all uppercase to match the tp and secchi datasets
##look into the other data sets and these data sets to see what is actually going on

```

Merge the tp and the secchi data sets into 1
===

```{r}
n_distinct(tp$lagoslakeid) ##4054
n_distinct(secchi$lagoslakeid) ##6271
n_distinct(tp$lagoslakeid[tp$state_name == "Wisconsin"]) ##945
n_distinct(secchi$lagoslakeid[secchi$state_name == "Wisconsin"]) ##1227
##probably want to start with the tp because of less lakes ==> so get only lake id, and the secchi stats to merge with the tp dataset
secchiFiltered <- secchi%>%select(lagoslakeid, mean_secchi, median_secchi, sd_secchi, covar_secchi, nobs_secchi)

##now actually merge to tp and the secchiFiltered together to make lagos, should be 4054 rows
lagos <- tp%>%left_join(secchiFiltered, by = "lagoslakeid")
dim(lagos) ##4054 yes

##subset down to just wisconin lakes, should be 945
wisLagos <- lagos%>%filter(state_name == "Wisconsin")
dim(wisLagos) ## 945 yes
n_distinct(wisLagos$lagoslakeid) ## 945 different lake id's
n_distinct(wisLagos$lagosname1) ##742 different name ==> i know for sure that there are some lakes in the state that have the same name but are in totally different places

##get rid of lakes with no secchi mean/median measurements or mean depth / max depth
wisLagos <- wisLagos[!is.na(wisLagos$mean_secchi),]
wisLagos <- wisLagos[!is.na(wisLagos$meandepth),]
##Now
dim(wisLagos) ## 585 entries
n_distinct(wisLagos$lagoslakeid) ## 585 different lake id's
n_distinct(wisLagos$lagosname1) ##488 different lake names ## little bit better percent of unique lake names but still going to be interesting when merging with the lakesRec data set where we have just names and only sort of matching lat and long
```

Cluster on the wisLagos data set
===

```{r}
##get the set of variables I want to cluster on
wisLagosClusterSet <- wisLagos%>%select(lagoslakeid,mean_TP, mean_secchi, lake_area_ha, lake_perim_meters, meandepth, maxdepth, pcturbancombined_hu12, pctagcombined_hu12)
##scale the data (minus the lakeid column)
wisLagosScaled <- scale(wisLagosClusterSet[,-1])
##perform the clustering
wis.3 <- kmeans(wisLagosScaled, centers = 3, iter.max = 100, nstart = 25)
wis.4 <- kmeans(wisLagosScaled, centers = 4, iter.max = 100, nstart = 25)
wis.5 <- kmeans(wisLagosScaled, centers = 5, iter.max = 100, nstart = 25)
##plot the clustering
fviz_cluster(wis.3, data = wisLagosScaled, geom = "point", ellipse.type = "norm") 
fviz_cluster(wis.4, data = wisLagosScaled, geom = "point", ellipse.type = "norm")
fviz_cluster(wis.5, data = wisLagosScaled, geom = "point", ellipse.type = "norm")
## i would go with the 3 cluster approach again
##figure out what the clusters mean
pairs(wisLagosClusterSet[,-1], panel=function(x,y) text(x,y,wis.3$cluster))
pairs(wisLagosClusterSet[,-1], col = wis.3$cluster)

wisClust <- data.frame(lagoslakeid = wisLagosClusterSet$lagoslakeid, Cluster = wis.3$cluster)
wisClust$ClusterType <- ifelse(wisClust$Cluster == 1, "ShallowNotClear",
                               ifelse(wisClust$Cluster == 2, "BigLakes", "DeepClear"))
wisClust
wisLagos <- wisLagos%>%left_join(wisClust, by = "lagoslakeid")
wisLagos ##should be all good and ready to be merged somehow, and maybe be chosen too idk
##write.csv(wisLagos, "wisLagos.csv", row.names = F)
```

### k means scree plot

```{r}
##k means scree plot
k.max <- 15
data <- wisLagosScaled
wss <- sapply(1:k.max, 
              function(k){kmeans(data, k, nstart=50,iter.max = 15 )$tot.withinss})
wss
plot(1:k.max, wss,
     type="b", pch = 19, frame = FALSE, 
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")
```

Analyzing our clusters
===

```{r}
##looking at difference in mean TP
mod1 <- aov(mean_TP ~ ClusterType, data = wisLagos)
anova(mod1) ##significant
TukeyHSD(mod1) ## Big Lakes > Deep, Big Lakes > Shallow, Shallow > Deep

##looking at difference in mean secchi depth
mod2 <- aov(mean_secchi ~ ClusterType, data = wisLagos)
anova(mod2) ##significant
TukeyHSD(mod2) ## Deep > Big Lakes, Deep > Shallow
```


Merging the wisLagos and lakesRec data sets
===

```{r}
merge1 <- wisLagos%>%left_join(lakesRec, by = c("lagosname1" = "Lake.Name"))
dim(merge1) ## 1669 rows ==> one more than the lakesRec dataset, 156 bass lakes now (6*26)

##Create my distance function
library(geosphere)

Distance <- function(latLongPairs) {
  dist <- distCosine(c(latLongPairs[2], latLongPairs[1]), c(latLongPairs[4], latLongPairs[3])) / 1609
  return(dist)
}

merge1 <- merge1[!is.na(merge1$Latitude),]
dim(merge1) ##now only 1597 entries
latLong <- merge1%>%select(nhd_lat, nhd_long, Latitude, Longitude)
merge1$Distance <- apply(latLong,1, Distance)
merge1 <- merge1%>%mutate(DiffAcre = abs((lake_area_ha * 2.47105) - Size..Acres.))

merge1%>%select(lake_area_ha, Size..Acres., lagosname1, Distance, DiffAcre)%>%filter(lagosname1 == "PERCH LAKE")

merge1a <- merge1%>%filter(Distance <= 5 & DiffAcre <= 3000)
dim(merge1a) ## 489

n_distinct(merge1a$lagoslakeid) ## 489 diff lake id's
n_distinct(merge1a$lagosname1) ## 410 different lake names
##write.csv(merge1a, "mergeTest1.csv", row.names = F)

wisComplete <- merge1a ##final complete data set that we want
##look at the lakes with "" for water clarity, might want to get rid of these ==> only 34
wisComplete <- wisComplete%>%filter(Water.Clarity != "")
n_distinct(wisComplete$lagoslakeid) ##455 lakes
n_distinct(wisComplete$lagosname1) ##381 unique lake names

table(wisComplete$ClusterType, wisComplete$Water.Clarity)
```

### Choosing which lakes to look into first

Read in out ecoregions csv's and assign the regions
===

```{r}
driftless <- read.csv("driftless.csv", header = T)
dim(driftless)
north <- read.csv("northernLakesForests.csv", header = T)
dim(north)
southEast <- read.csv("seWisTillPlains.csv", header = T)
dim(southEast)

wisComplete$EcoRegion <- ifelse(wisComplete$lagoslakeid %in% driftless$Lagoslakeid, "Driftless Area",
                                ifelse(wisComplete$lagoslakeid %in% north$Lagoslakeid, "Northern Lakes and Forests",
                                       ifelse(wisComplete$lagoslakeid %in% southEast$Lagoslakeid, "Southeastern Wisconsin Till Plains", "North Central Hardwood Forests")))

wisComplete$EcoRegion <- as.factor(wisComplete$EcoRegion)##looks good
##write.csv(wisComplete, "wisCompleteEco.csv", row.names = F)


```


Getting ready to sample from each region type combination
===

```{r}
## filter out lakes with same name as others
numberLakes <- wisComplete%>%group_by(lagosname1)%>%summarise(Count = n())
uniqueLakes <- numberLakes$lagosname1[numberLakes$Count == 1]
lakes <- wisComplete%>%filter(lagosname1 %in% uniqueLakes)
dim(lakes) ## 340 lakes where they have unique names
## subset down to eco region
driftB <- lakes%>%filter(EcoRegion == "Driftless Area" & ClusterType == "BigLakes")
driftS <- lakes%>%filter(EcoRegion == "Driftless Area" & ClusterType == "ShallowNotClear")
driftD <- lakes%>%filter(EcoRegion == "Driftless Area" & ClusterType == "DeepClear")

northB <- lakes%>%filter(EcoRegion == "Northern Lakes and Forests" & ClusterType == "BigLakes")
northS <- lakes%>%filter(EcoRegion == "Northern Lakes and Forests" & ClusterType == "ShallowNotClear")
northD <- lakes%>%filter(EcoRegion == "Northern Lakes and Forests" & ClusterType == "DeepClear")


centralB <- lakes%>%filter(EcoRegion == "North Central Hardwood Forests" & ClusterType == "BigLakes")
centralS <- lakes%>%filter(EcoRegion == "North Central Hardwood Forests" & ClusterType == "ShallowNotClear")
centralD <- lakes%>%filter(EcoRegion == "North Central Hardwood Forests" & ClusterType == "DeepClear")

southB <- lakes%>%filter(EcoRegion == "Southeastern Wisconsin Till Plains" & ClusterType == "BigLakes")
southS <- lakes%>%filter(EcoRegion == "Southeastern Wisconsin Till Plains" & ClusterType == "ShallowNotClear")
southD <- lakes%>%filter(EcoRegion == "Southeastern Wisconsin Till Plains" & ClusterType == "DeepClear")
```

Sampling the lakes
===

```{r}
set.seed(123)
sample(driftB$lagosname1, 1) ##Lake Onalaska
sample(driftS$lagosname1, 1) ##Lake EAU GALLE
sample(driftD$lagosname1, 1) ##no deep lakes in this region
sample(northB$lagosname1, 1) ## Willow Flowage
sample(northS$lagosname1, 1) ##Towanda Lake / Tabor Lake
sample(northD$lagosname1, 1) ##Squash Lake
sample(centralB$lagosname1, 1) ## Shawano Lake
sample(centralS$lagosname1, 1) ##Hatch Lake
sample(centralD$lagosname1, 1) ##McGee Lake
sample(southB$lagosname1, 1) ##Gonna do Lake Mendota
sample(southS$lagosname1, 1) ##Lake Waubesa
sample(southD$lagosname1, 1) ##Druid Lake

myLakes <- c("LAKE ONALASKA", "LAKE EAU GALLE", "WILLOW FLOWAGE", "TOWANDA LAKE", "TABOR LAKE", "SQUASH LAKE", "SHAWANO LAKE", "HATCH LAKE", "MCGEE LAKE", "LAKE MENDOTA", "LAKE WAUBESA", "DRUID LAKE")

myLakeDF <- wisComplete%>%filter(lagosname1 %in% myLakes)

wisconsin <- get_map(location = "Wisconsin", zoom = 6)
ggmap(wisconsin) + geom_point(data = myLakeDF, aes(x = nhd_long, y = nhd_lat, col = ClusterType, shape = EcoRegion), size = 4)
```

